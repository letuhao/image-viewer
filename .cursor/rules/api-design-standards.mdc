---
description: API design standards and best practices for ImageViewer Platform
alwaysApply: true
---

# API Design Standards - ImageViewer Platform

## RESTful API Design

### URL Structure
- Use nouns, not verbs in URLs
- Use plural nouns for collections
- Use hierarchical structure for related resources
- Use query parameters for filtering, sorting, and pagination

### URL Examples
```
GET    /api/v1/collections                    # Get all collections
GET    /api/v1/collections/{id}               # Get specific collection
POST   /api/v1/collections                    # Create new collection
PUT    /api/v1/collections/{id}               # Update collection
DELETE /api/v1/collections/{id}               # Delete collection

GET    /api/v1/collections/{id}/media-items   # Get media items in collection
POST   /api/v1/collections/{id}/media-items   # Add media item to collection
GET    /api/v1/collections/{id}/tags          # Get tags for collection
POST   /api/v1/collections/{id}/tags          # Add tag to collection
```

### HTTP Methods
- **GET**: Retrieve resources
- **POST**: Create new resources
- **PUT**: Update entire resources
- **PATCH**: Partial updates
- **DELETE**: Remove resources
- **HEAD**: Get headers only
- **OPTIONS**: Get allowed methods

### HTTP Status Codes
- **200 OK**: Successful GET, PUT, PATCH
- **201 Created**: Successful POST
- **204 No Content**: Successful DELETE
- **400 Bad Request**: Invalid request data
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Insufficient permissions
- **404 Not Found**: Resource not found
- **409 Conflict**: Resource conflict
- **422 Unprocessable Entity**: Validation errors
- **500 Internal Server Error**: Server error

## Controller Design

### Controller Structure
```csharp
[ApiController]
[Route("api/v1/[controller]")]
[Produces("application/json")]
public class CollectionsController : ControllerBase
{
    private readonly ICollectionApplicationService _collectionService;
    private readonly ILogger<CollectionsController> _logger;
    
    public CollectionsController(
        ICollectionApplicationService collectionService,
        ILogger<CollectionsController> logger)
    {
        _collectionService = collectionService;
        _logger = logger;
    }
    
    [HttpGet]
    [ProducesResponseType(typeof(PagedResult<CollectionDto>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<PagedResult<CollectionDto>>> GetCollections(
        [FromQuery] GetCollectionsRequest request)
    {
        try
        {
            var result = await _collectionService.GetCollectionsAsync(request);
            return Ok(result);
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(ex, "Validation error in GetCollections");
            return BadRequest(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GetCollections");
            return StatusCode(500, "An error occurred while processing your request");
        }
    }
    
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(CollectionDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<CollectionDto>> GetCollection(ObjectId id)
    {
        try
        {
            var collection = await _collectionService.GetCollectionAsync(id);
            return Ok(collection);
        }
        catch (CollectionNotFoundException ex)
        {
            _logger.LogWarning(ex, "Collection not found: {CollectionId}", id);
            return NotFound(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GetCollection for ID {CollectionId}", id);
            return StatusCode(500, "An error occurred while processing your request");
        }
    }
    
    [HttpPost]
    [ProducesResponseType(typeof(CollectionDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<ActionResult<CollectionDto>> CreateCollection(
        [FromBody] CreateCollectionRequest request)
    {
        try
        {
            var collection = await _collectionService.CreateCollectionAsync(request);
            return CreatedAtAction(nameof(GetCollection), new { id = collection.Id }, collection);
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(ex, "Validation error in CreateCollection");
            return BadRequest(ex.Message);
        }
        catch (DuplicateCollectionException ex)
        {
            _logger.LogWarning(ex, "Duplicate collection in CreateCollection");
            return Conflict(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in CreateCollection");
            return StatusCode(500, "An error occurred while processing your request");
        }
    }
    
    [HttpPut("{id}")]
    [ProducesResponseType(typeof(CollectionDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<ActionResult<CollectionDto>> UpdateCollection(
        ObjectId id, 
        [FromBody] UpdateCollectionRequest request)
    {
        try
        {
            var collection = await _collectionService.UpdateCollectionAsync(id, request);
            return Ok(collection);
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(ex, "Validation error in UpdateCollection for ID {CollectionId}", id);
            return BadRequest(ex.Message);
        }
        catch (CollectionNotFoundException ex)
        {
            _logger.LogWarning(ex, "Collection not found in UpdateCollection: {CollectionId}", id);
            return NotFound(ex.Message);
        }
        catch (DuplicateCollectionException ex)
        {
            _logger.LogWarning(ex, "Duplicate collection in UpdateCollection for ID {CollectionId}", id);
            return Conflict(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in UpdateCollection for ID {CollectionId}", id);
            return StatusCode(500, "An error occurred while processing your request");
        }
    }
    
    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult> DeleteCollection(ObjectId id)
    {
        try
        {
            await _collectionService.DeleteCollectionAsync(id);
            return NoContent();
        }
        catch (CollectionNotFoundException ex)
        {
            _logger.LogWarning(ex, "Collection not found in DeleteCollection: {CollectionId}", id);
            return NotFound(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in DeleteCollection for ID {CollectionId}", id);
            return StatusCode(500, "An error occurred while processing your request");
        }
    }
}
```

## Request/Response Models

### Request Models
```csharp
public class CreateCollectionRequest
{
    [Required]
    [StringLength(100, MinimumLength = 1)]
    public string Name { get; set; }
    
    [Required]
    [StringLength(500, MinimumLength = 1)]
    public string Path { get; set; }
    
    [Required]
    public CollectionType Type { get; set; }
    
    [Required]
    public ObjectId LibraryId { get; set; }
    
    [StringLength(1000)]
    public string Description { get; set; }
    
    public List<string> Tags { get; set; } = new();
    
    public Dictionary<string, object> CustomFields { get; set; } = new();
    
    public bool AutoScan { get; set; } = true;
    public bool GenerateThumbnails { get; set; } = true;
    public bool GenerateCache { get; set; } = true;
    public bool EnableWatching { get; set; } = false;
}

public class UpdateCollectionRequest
{
    [StringLength(100, MinimumLength = 1)]
    public string Name { get; set; }
    
    [StringLength(500, MinimumLength = 1)]
    public string Path { get; set; }
    
    [StringLength(1000)]
    public string Description { get; set; }
    
    public List<string> Tags { get; set; }
    
    public Dictionary<string, object> CustomFields { get; set; }
    
    public bool? AutoScan { get; set; }
    public bool? GenerateThumbnails { get; set; }
    public bool? GenerateCache { get; set; }
    public bool? EnableWatching { get; set; }
}

public class GetCollectionsRequest
{
    [Range(1, 1000)]
    public int Page { get; set; } = 1;
    
    [Range(1, 100)]
    public int Limit { get; set; } = 20;
    
    public string SortBy { get; set; } = "name";
    public string SortOrder { get; set; } = "asc";
    
    public string Search { get; set; }
    public CollectionType? Type { get; set; }
    public ObjectId? LibraryId { get; set; }
    public List<string> Tags { get; set; } = new();
}
```

### Response Models
```csharp
public class CollectionDto
{
    public ObjectId Id { get; set; }
    public ObjectId LibraryId { get; set; }
    public string Name { get; set; }
    public string Path { get; set; }
    public CollectionType Type { get; set; }
    
    public CollectionSettingsDto Settings { get; set; }
    public CollectionMetadataDto Metadata { get; set; }
    public CollectionStatisticsDto Statistics { get; set; }
    public WatchInfoDto WatchInfo { get; set; }
    
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class CollectionSettingsDto
{
    public bool Enabled { get; set; }
    public bool AutoScan { get; set; }
    public bool GenerateThumbnails { get; set; }
    public bool GenerateCache { get; set; }
}

public class CollectionMetadataDto
{
    public string Description { get; set; }
    public List<string> Tags { get; set; }
    public Dictionary<string, object> CustomFields { get; set; }
}

public class CollectionStatisticsDto
{
    public int TotalItems { get; set; }
    public long TotalSize { get; set; }
    public DateTime? LastScanDate { get; set; }
    public int ScanCount { get; set; }
}

public class WatchInfoDto
{
    public bool IsWatching { get; set; }
    public string WatchPath { get; set; }
    public List<string> WatchFilters { get; set; }
}

public class PagedResult<T>
{
    public List<T> Data { get; set; }
    public int Page { get; set; }
    public int Limit { get; set; }
    public int Total { get; set; }
    public int TotalPages { get; set; }
    public bool HasNext { get; set; }
    public bool HasPrevious { get; set; }
}
```

## Error Handling

### Error Response Model
```csharp
public class ErrorResponse
{
    public string Error { get; set; }
    public string Message { get; set; }
    public string Details { get; set; }
    public string RequestId { get; set; }
    public DateTime Timestamp { get; set; }
    public List<ValidationError> ValidationErrors { get; set; }
}

public class ValidationError
{
    public string Field { get; set; }
    public string Message { get; set; }
    public object AttemptedValue { get; set; }
}
```

### Global Exception Handler
```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    
    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var requestId = context.TraceIdentifier;
        var errorResponse = new ErrorResponse
        {
            RequestId = requestId,
            Timestamp = DateTime.UtcNow
        };
        
        switch (exception)
        {
            case ValidationException validationEx:
                errorResponse.Error = "VALIDATION_ERROR";
                errorResponse.Message = "One or more validation errors occurred";
                errorResponse.ValidationErrors = validationEx.Errors.Select(e => new ValidationError
                {
                    Field = e.PropertyName,
                    Message = e.ErrorMessage,
                    AttemptedValue = e.AttemptedValue
                }).ToList();
                context.Response.StatusCode = 400;
                break;
                
            case CollectionNotFoundException:
                errorResponse.Error = "COLLECTION_NOT_FOUND";
                errorResponse.Message = exception.Message;
                context.Response.StatusCode = 404;
                break;
                
            case DuplicateCollectionException:
                errorResponse.Error = "DUPLICATE_COLLECTION";
                errorResponse.Message = exception.Message;
                context.Response.StatusCode = 409;
                break;
                
            case UnauthorizedAccessException:
                errorResponse.Error = "UNAUTHORIZED";
                errorResponse.Message = "Access denied";
                context.Response.StatusCode = 403;
                break;
                
            default:
                errorResponse.Error = "INTERNAL_SERVER_ERROR";
                errorResponse.Message = "An unexpected error occurred";
                context.Response.StatusCode = 500;
                _logger.LogError(exception, "Unhandled exception in request {RequestId}", requestId);
                break;
        }
        
        context.Response.ContentType = "application/json";
        var jsonResponse = JsonSerializer.Serialize(errorResponse);
        await context.Response.WriteAsync(jsonResponse);
    }
}
```

## Authentication and Authorization

### JWT Authentication
```csharp
[ApiController]
[Route("api/v1/[controller]")]
[Authorize]
public class CollectionsController : ControllerBase
{
    [HttpGet]
    [Authorize(Policy = "ReadCollections")]
    public async Task<ActionResult<PagedResult<CollectionDto>>> GetCollections(
        [FromQuery] GetCollectionsRequest request)
    {
        // Implementation
    }
    
    [HttpPost]
    [Authorize(Policy = "CreateCollections")]
    public async Task<ActionResult<CollectionDto>> CreateCollection(
        [FromBody] CreateCollectionRequest request)
    {
        // Implementation
    }
    
    [HttpPut("{id}")]
    [Authorize(Policy = "UpdateCollections")]
    public async Task<ActionResult<CollectionDto>> UpdateCollection(
        ObjectId id, 
        [FromBody] UpdateCollectionRequest request)
    {
        // Implementation
    }
    
    [HttpDelete("{id}")]
    [Authorize(Policy = "DeleteCollections")]
    public async Task<ActionResult> DeleteCollection(ObjectId id)
    {
        // Implementation
    }
}
```

### API Key Authentication
```csharp
[ApiController]
[Route("api/v1/[controller]")]
[ApiKeyAuth]
public class PublicCollectionsController : ControllerBase
{
    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<PagedResult<PublicCollectionDto>>> GetPublicCollections(
        [FromQuery] GetPublicCollectionsRequest request)
    {
        // Implementation for public access
    }
}
```

## API Versioning

### URL Versioning
```csharp
[ApiController]
[Route("api/v1/[controller]")]
[ApiVersion("1.0")]
public class CollectionsV1Controller : ControllerBase
{
    // V1 implementation
}

[ApiController]
[Route("api/v2/[controller]")]
[ApiVersion("2.0")]
public class CollectionsV2Controller : ControllerBase
{
    // V2 implementation
}
```

### Header Versioning
```csharp
[ApiController]
[Route("api/[controller]")]
[ApiVersion("1.0", "2.0")]
public class CollectionsController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public async Task<ActionResult<PagedResult<CollectionDto>>> GetCollectionsV1(
        [FromQuery] GetCollectionsRequest request)
    {
        // V1 implementation
    }
    
    [HttpGet]
    [MapToApiVersion("2.0")]
    public async Task<ActionResult<PagedResult<CollectionV2Dto>>> GetCollectionsV2(
        [FromQuery] GetCollectionsV2Request request)
    {
        // V2 implementation
    }
}
```

## API Documentation

### Swagger/OpenAPI Configuration
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(c =>
    {
        c.SwaggerDoc("v1", new OpenApiInfo
        {
            Title = "ImageViewer API",
            Version = "v1",
            Description = "API for ImageViewer Platform",
            Contact = new OpenApiContact
            {
                Name = "ImageViewer Team",
                Email = "support@imageviewer.com"
            }
        });
        
        c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
        {
            Description = "JWT Authorization header using the Bearer scheme",
            Name = "Authorization",
            In = ParameterLocation.Header,
            Type = SecuritySchemeType.ApiKey,
            Scheme = "Bearer"
        });
        
        c.AddSecurityRequirement(new OpenApiSecurityRequirement
        {
            {
                new OpenApiSecurityScheme
                {
                    Reference = new OpenApiReference
                    {
                        Type = ReferenceType.SecurityScheme,
                        Id = "Bearer"
                    }
                },
                new string[] {}
            }
        });
        
        var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
        var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
        c.IncludeXmlComments(xmlPath);
    });
}
```

### XML Documentation
```csharp
/// <summary>
/// Gets a collection of collections with optional filtering and pagination
/// </summary>
/// <param name="request">Query parameters for filtering and pagination</param>
/// <returns>A paged result of collections</returns>
/// <response code="200">Returns the requested collections</response>
/// <response code="400">If the request parameters are invalid</response>
/// <response code="401">If the user is not authenticated</response>
/// <response code="403">If the user does not have permission to read collections</response>
[HttpGet]
[ProducesResponseType(typeof(PagedResult<CollectionDto>), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
[ProducesResponseType(StatusCodes.Status401Unauthorized)]
[ProducesResponseType(StatusCodes.Status403Forbidden)]
public async Task<ActionResult<PagedResult<CollectionDto>>> GetCollections(
    [FromQuery] GetCollectionsRequest request)
{
    // Implementation
}
```

## Performance Optimization

### Response Caching
```csharp
[HttpGet("{id}")]
[ResponseCache(Duration = 300, VaryByQueryKeys = new[] { "id" })]
public async Task<ActionResult<CollectionDto>> GetCollection(ObjectId id)
{
    // Implementation
}
```

### Compression
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddResponseCompression(options =>
    {
        options.EnableForHttps = true;
        options.Providers.Add<GzipCompressionProvider>();
    });
}
```

### Rate Limiting
```csharp
[HttpGet]
[EnableRateLimiting("CollectionsPolicy")]
public async Task<ActionResult<PagedResult<CollectionDto>>> GetCollections(
    [FromQuery] GetCollectionsRequest request)
{
    // Implementation
}
```

## API Best Practices

### 1. Consistent Response Format
- Use consistent response structure across all endpoints
- Include metadata like pagination info, timestamps, request IDs
- Use appropriate HTTP status codes

### 2. Proper Error Handling
- Return meaningful error messages
- Include error codes for programmatic handling
- Log errors appropriately
- Don't expose sensitive information

### 3. Input Validation
- Validate all input parameters
- Use data annotations for simple validation
- Use FluentValidation for complex validation
- Return validation errors in consistent format

### 4. Security
- Use HTTPS for all communications
- Implement proper authentication and authorization
- Validate and sanitize all inputs
- Use rate limiting to prevent abuse

### 5. Performance
- Use appropriate HTTP methods
- Implement caching where appropriate
- Use compression for large responses
- Optimize database queries

### 6. Documentation
- Document all endpoints with Swagger/OpenAPI
- Include examples in documentation
- Keep documentation up to date
- Provide clear error codes and messages

### 7. Versioning
- Implement API versioning strategy
- Maintain backward compatibility
- Deprecate old versions gracefully
- Communicate changes to consumers

### 8. Testing
- Write comprehensive unit tests
- Write integration tests for API endpoints
- Test error scenarios
- Test authentication and authorization