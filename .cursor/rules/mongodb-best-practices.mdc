---
description: MongoDB best practices and patterns for ImageViewer Platform
alwaysApply: true
---

# MongoDB Best Practices - ImageViewer Platform

## Document Design

### Document Structure
- Design documents to match application access patterns
- Use embedded documents for related data that is always accessed together
- Use references for data that is accessed independently
- Keep document size under 16MB limit
- Use meaningful field names

### Schema Design Patterns
```csharp
// Good: Embedded document for related data
public class Collection
{
    [BsonId]
    public ObjectId Id { get; set; }
    
    public string Name { get; set; }
    public string Path { get; set; }
    
    // Embedded document for settings
    public CollectionSettings Settings { get; set; }
    
    // Embedded document for metadata
    public CollectionMetadata Metadata { get; set; }
    
    // Embedded document for statistics
    public CollectionStatistics Statistics { get; set; }
}

// Good: Reference for independent data
public class MediaItem
{
    [BsonId]
    public ObjectId Id { get; set; }
    
    public ObjectId CollectionId { get; set; } // Reference to collection
    public string Name { get; set; }
    public string Path { get; set; }
}
```

### Data Types
- Use `ObjectId` for primary keys
- Use `DateTime` for timestamps (stored as UTC)
- Use appropriate BSON types for data
- Use arrays for multiple values
- Use embedded documents for complex structures

## Indexing Strategy

### Index Types
- Create single-field indexes for frequently queried fields
- Create compound indexes for multi-field queries
- Create text indexes for search functionality
- Create TTL indexes for time-based data
- Create sparse indexes for optional fields

### Index Examples
```csharp
// Single-field index
db.collections.createIndex({ "name": 1 });

// Compound index
db.collections.createIndex({ "libraryId": 1, "type": 1 });

// Text index for search
db.collections.createIndex({ "name": "text", "description": "text" });

// TTL index for temporary data
db.userSessions.createIndex({ "expiresAt": 1 }, { expireAfterSeconds: 0 });

// Sparse index for optional fields
db.users.createIndex({ "email": 1 }, { sparse: true });
```

### Index Optimization
- Monitor index usage with `db.collection.getIndexes()`
- Remove unused indexes to improve write performance
- Use `explain()` to analyze query performance
- Consider index intersection for complex queries

## Query Optimization

### Query Patterns
- Use projection to limit returned fields
- Use appropriate query operators
- Use aggregation pipelines for complex operations
- Implement pagination for large result sets
- Use `findOne()` instead of `find().limit(1)`

### Query Examples
```csharp
// Good: Use projection
var collections = await _collections
    .Find(c => c.LibraryId == libraryId)
    .Project(c => new { c.Id, c.Name, c.Type })
    .ToListAsync();

// Good: Use appropriate operators
var recentCollections = await _collections
    .Find(c => c.CreatedAt >= DateTime.UtcNow.AddDays(-30))
    .SortByDescending(c => c.CreatedAt)
    .Limit(10)
    .ToListAsync();

// Good: Use aggregation for complex queries
var pipeline = new BsonDocument[]
{
    new BsonDocument("$match", new BsonDocument("libraryId", libraryId)),
    new BsonDocument("$group", new BsonDocument
    {
        { "_id", "$type" },
        { "count", new BsonDocument("$sum", 1) },
        { "totalSize", new BsonDocument("$sum", "$statistics.totalSize") }
    })
};

var results = await _collections.Aggregate<BsonDocument>(pipeline).ToListAsync();
```

### Performance Tips
- Use `explain()` to analyze query performance
- Monitor slow queries in MongoDB logs
- Use appropriate indexes for queries
- Avoid full collection scans
- Use `limit()` to restrict result sets

## Aggregation Pipelines

### Pipeline Stages
- Use `$match` early in pipeline to filter documents
- Use `$project` to reshape documents
- Use `$group` for aggregation operations
- Use `$sort` for ordering results
- Use `$limit` and `$skip` for pagination

### Pipeline Examples
```csharp
// Complex aggregation pipeline
var pipeline = new BsonDocument[]
{
    // Match collections in specific library
    new BsonDocument("$match", new BsonDocument("libraryId", libraryId)),
    
    // Lookup related media items
    new BsonDocument("$lookup", new BsonDocument
    {
        { "from", "mediaItems" },
        { "localField", "_id" },
        { "foreignField", "collectionId" },
        { "as", "mediaItems" }
    }),
    
    // Add computed fields
    new BsonDocument("$addFields", new BsonDocument
    {
        { "mediaCount", new BsonDocument("$size", "$mediaItems") },
        { "totalSize", new BsonDocument("$sum", "$mediaItems.fileSize") }
    }),
    
    // Project final fields
    new BsonDocument("$project", new BsonDocument
    {
        { "name", 1 },
        { "type", 1 },
        { "mediaCount", 1 },
        { "totalSize", 1 },
        { "createdAt", 1 }
    }),
    
    // Sort by creation date
    new BsonDocument("$sort", new BsonDocument("createdAt", -1)),
    
    // Limit results
    new BsonDocument("$limit", 20)
};

var results = await _collections.Aggregate<BsonDocument>(pipeline).ToListAsync();
```

## Connection Management

### Connection String
```csharp
// Good: Use connection string with options
var connectionString = "mongodb://localhost:27017/imageviewer?retryWrites=true&w=majority";

// Good: Use connection string with authentication
var connectionString = "mongodb://username:password@localhost:27017/imageviewer?authSource=admin";
```

### Connection Pooling
- Use default connection pooling settings
- Monitor connection pool usage
- Set appropriate connection limits
- Use connection string options for optimization

### Connection Options
```csharp
var settings = MongoClientSettings.FromConnectionString(connectionString);
settings.ServerSelectionTimeout = TimeSpan.FromSeconds(30);
settings.ConnectTimeout = TimeSpan.FromSeconds(10);
settings.SocketTimeout = TimeSpan.FromSeconds(30);
settings.MaxConnectionPoolSize = 100;
settings.MinConnectionPoolSize = 10;
```

## Error Handling

### Exception Types
- Handle `MongoException` for database errors
- Handle `MongoConnectionException` for connection issues
- Handle `MongoWriteException` for write operation errors
- Handle `MongoQueryException` for query errors

### Error Handling Examples
```csharp
public async Task<Collection> CreateCollectionAsync(Collection collection)
{
    try
    {
        await _collections.InsertOneAsync(collection);
        return collection;
    }
    catch (MongoWriteException ex) when (ex.WriteError.Category == ServerErrorCategory.DuplicateKey)
    {
        throw new DuplicateCollectionException($"Collection with name '{collection.Name}' already exists", ex);
    }
    catch (MongoException ex)
    {
        _logger.LogError(ex, "Failed to create collection {CollectionName}", collection.Name);
        throw new DatabaseException("Failed to create collection", ex);
    }
}
```

## Transaction Management

### Transaction Usage
- Use transactions for multi-document operations
- Keep transactions short to avoid deadlocks
- Use appropriate read and write concerns
- Handle transaction conflicts gracefully

### Transaction Examples
```csharp
public async Task<Collection> CreateCollectionWithMediaItemsAsync(Collection collection, List<MediaItem> mediaItems)
{
    using var session = await _client.StartSessionAsync();
    
    try
    {
        session.StartTransaction();
        
        // Insert collection
        await _collections.InsertOneAsync(session, collection);
        
        // Insert media items
        if (mediaItems.Any())
        {
            await _mediaItems.InsertManyAsync(session, mediaItems);
        }
        
        await session.CommitTransactionAsync();
        return collection;
    }
    catch (Exception ex)
    {
        await session.AbortTransactionAsync();
        _logger.LogError(ex, "Failed to create collection with media items");
        throw;
    }
}
```

## Monitoring and Logging

### Performance Monitoring
- Monitor query performance with `db.collection.explain()`
- Use MongoDB profiler for slow queries
- Monitor connection pool usage
- Track index usage and effectiveness

### Logging
```csharp
// Log query performance
var stopwatch = Stopwatch.StartNew();
var results = await _collections.Find(filter).ToListAsync();
stopwatch.Stop();

_logger.LogInformation("Query executed in {ElapsedMs}ms, returned {Count} documents", 
    stopwatch.ElapsedMilliseconds, results.Count);

// Log slow queries
if (stopwatch.ElapsedMilliseconds > 1000)
{
    _logger.LogWarning("Slow query detected: {ElapsedMs}ms, filter: {Filter}", 
        stopwatch.ElapsedMilliseconds, filter);
}
```

## Security

### Authentication
- Use strong passwords for database users
- Use role-based access control
- Enable authentication in production
- Use SSL/TLS for connections

### Data Protection
- Encrypt sensitive data at application level
- Use field-level encryption for PII
- Implement proper access controls
- Audit database access

### Connection Security
```csharp
// Use SSL connection
var connectionString = "mongodb://localhost:27017/imageviewer?ssl=true&sslVerifyCertificate=true";

// Use authentication
var connectionString = "mongodb://username:password@localhost:27017/imageviewer?authSource=admin";
```

## Backup and Recovery

### Backup Strategy
- Use `mongodump` for logical backups
- Use filesystem snapshots for physical backups
- Test backup restoration regularly
- Implement automated backup schedules

### Recovery Procedures
- Document recovery procedures
- Test recovery scenarios
- Maintain backup retention policies
- Monitor backup success/failure

## Best Practices Summary

1. **Design for Access Patterns**: Structure documents based on how they're accessed
2. **Use Appropriate Indexes**: Create indexes for frequently queried fields
3. **Optimize Queries**: Use projection, appropriate operators, and aggregation
4. **Handle Errors Gracefully**: Implement proper exception handling
5. **Monitor Performance**: Track query performance and optimize as needed
6. **Secure Connections**: Use authentication and SSL/TLS
7. **Implement Backups**: Regular backups with tested recovery procedures
8. **Use Transactions Wisely**: For multi-document operations only
9. **Log Appropriately**: Log performance metrics and errors
10. **Test Thoroughly**: Test all database operations and error scenarios